package net.projecteuler.java;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
 * are all figurate (polygonal) numbers and are generated by the following formulae:<p>
 * Triangle     P<sub>3,n</sub>=n(n+1)/2      -> 1, 3, 6, 10, 15, ...</br>
 * Square	 	P<sub>4,n</sub>=n<sup>2</sup> -> 1, 4, 9, 16, 25, ...</br>
 * Pentagonal	P<sub>5,n</sub>=n(3n-1)/2     -> 1, 5, 12, 22, 35, ...</br>
 * Hexagonal	P<sub>6,n</sub>=n(2n-1)       -> 1, 6, 15, 28, 45, ...</br>
 * Heptagonal	P<sub>7,n</sub>=n(5n-3)/2     -> 1, 7, 18, 34, 55, ...</br>
 * Octagonal	P<sub>8,n</sub>=n(3n-2)       -> 1, 8, 21, 40, 65, ...</br>
 * </p>
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
 * interesting properties.</br>
 * The set is cyclic, in that the last two digits of each number is the
 * first two digits of the next number (including the last number with the first).</br>
 * Each polygonal type: triangle (P<sub>3,127</sub>=8128), square (P<sub>4,91</sub>=8281), and pentagonal
 * (P<sub>5,44</sub>=2882), is represented by a different number in the set.
 * This is the only set of 4-digit numbers with this property.</br>
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for
 * which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal,
 * and octagonal, is represented by a different number in the set.
 *
 * @author vuser
 *
 */
public class Problem061 {

	private static int sum = 0;

	public static void main(String ... args) {
		for (int i : Polygon.TRIANGLE.numbers()) {
			LinkedList<PolygonNumber> polygons = new LinkedList<PolygonNumber>();
			calculate(new PolygonNumber(Polygon.TRIANGLE, i), polygons);
			if (sum > 0) {
				break;
			}
		}
		assert sum == 28684 : "failed";
	}

	private static boolean calculate(PolygonNumber number, LinkedList<PolygonNumber> polygons) {
		for (PolygonNumber n : polygons) {
			if (n.getPolygon() == number.getPolygon() || n.getValue() == number.getValue()) {
				return false;
			}
		}

		if (polygons.isEmpty()) {
			polygons.add(number);
		} else {
			// Compares the last two digits of the last number of the chain to
			// the first two digits of the number
			if (getLastDigits(polygons.getLast().getValue()) == getFirstDigits(number.getValue())) {
				polygons.add(number);
			} else {
				return false;
			}
		}

		if (polygons.size() == Polygon.values().length) {
			return true;
		}

		outer: for (Polygon p : Polygon.values()) {
			for (PolygonNumber n : polygons) {
				if (n.getPolygon() == p) {
					continue outer;
				}
			}
			for (int i : p.numbers()) {
				PolygonNumber n = new PolygonNumber(p, i);
				// Recursive call
				if (calculate(n, polygons)
						&& polygons.size() == Polygon.values().length
						&& getFirstDigits(polygons.getFirst().getValue()) == getLastDigits(i)) {
					// Chain is found - calculates the sum of the values
					System.out.println(polygons);
					sum(polygons);
					break outer;
				}
				polygons.remove(n);
			}
		}

		return sum > 0 ? true : false;

	}

	private static void sum(LinkedList<PolygonNumber> polygons) {
		for (PolygonNumber p : polygons) {
			sum += p.getValue();
		}
	}

	/**
	 * Gets first two digits of the given number.
	 * @param number
	 * @return
	 */
	private static int getFirstDigits(int number) {
		return (number - number % 100) / 100;
	}

	/**
	 * Gets last two digits of the given number.
	 * @param number
	 * @return
	 */
	private static int getLastDigits(int number) {
		return number % 100;
	}
}

class PolygonNumber {

	private final Polygon polygon;
	private final int value;

	public PolygonNumber(Polygon polygon, int value) {
		this.polygon = polygon;
		this.value = value;
	}

	public Polygon getPolygon() {
    	return polygon;
    }

	public int getValue() {
    	return value;
    }

	@Override
    public int hashCode() {
	    return (value + 1) * polygon.hashCode();
    }

	@Override
    public boolean equals(Object obj) {
	    if (obj == this) {
	    	return true;
	    }
	    if (obj instanceof PolygonNumber) {
	    	PolygonNumber p = (PolygonNumber) obj;
	    	return p.value == this.value && p.getPolygon() == this.polygon;
	    }
	    return false;
    }

	@Override
	public String toString() {
		return String.format("[%s - %d]", polygon, value);
	}
}

enum Polygon {

	TRIANGLE {
		List<Integer> numbers() {return triangles;}
	},
	SQUARE {
		List<Integer> numbers() {return squares;}
	},
	PENTAGONAL {
		List<Integer> numbers() {return pentagonals;}
	},
	HEXAGONAL {
		List<Integer> numbers() {return hexagonals;}
	},
	HEPTAGONAL {
		List<Integer> numbers() {return heptagonals;}
	},
	OCTAGONAL {
		List<Integer> numbers() {return octagonals;}
	};

	final static List<Integer> triangles = new ArrayList<Integer>();
	final static List<Integer> squares = new ArrayList<Integer>();
	final static List<Integer> pentagonals = new ArrayList<Integer>();
	final static List<Integer> hexagonals = new ArrayList<Integer>();
	final static List<Integer> heptagonals = new ArrayList<Integer>();
	final static List<Integer> octagonals = new ArrayList<Integer>();

	static {
		for (int i = 1; i < 150; i++) {
			add(i * (i + 1) / 2, triangles);
			add(i * i, squares);
			add(i * (3 * i - 1) / 2, pentagonals);
			add(i * (2 * i - 1), hexagonals);
			add(i * (5 * i - 3) / 2, heptagonals);
			add(i * (3 * i - 2), octagonals);
		}
	}

	private static void add(int number, List<Integer> set) {
		if (number >= 1000 && number < 10000 && number % 100 > 9) {
			set.add(number);
		}
	}

	abstract List<Integer> numbers();
}